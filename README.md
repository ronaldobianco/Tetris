<h1 align="center">
    <picture>
         <source media="(prefers-color-scheme: dark)" srcset="https://user-images.githubusercontent.com/16140783/223195620-a096252a-6930-40a7-ad28-bb31a8e7597e.png">
         <img width="700" src="https://user-images.githubusercontent.com/16140783/223195755-95ff4679-61b6-482d-95a2-f9f8e8adf391.png" align="center"></img>
    </picture>
</h1>
<p align="center">üõ†Ô∏è Making your express API setup as <strong>fast</strong> as it could be :)</p>

<p align="center">
  <a aria-label="Node version" href="https://github.com/nodejs/node/releases/tag/v19.6.0">
    <img src="https://img.shields.io/badge/nodejs-19.6.0-success?logo=Node.js"></img>
  </a>
  <a aria-label="Typescript version" href="https://github.com/microsoft/TypeScript/releases/tag/v4.9.5">
    <img src="https://img.shields.io/badge/typescript-4.9.5-success?logo=Typescript"></img>
  </a>
  <a aria-label="Express version" href="https://github.com/expressjs/express/releases/tag/4.18.2">
    <img src="https://img.shields.io/badge/express-4.18.2-success?logo=Express"></img>
  </a>
  <a aria-label="Express version" href="https://github.com/ateliware/blueprint-react">
    <img src="https://img.shields.io/badge/frontend-‚Æö-informational?logo=React"></img>
  </a>
  <a aria-label="Design system" href="https://github.com/ateliware/aquario">
    <img src="https://img.shields.io/badge/aquario-‚Æö-informational?logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAZCAYAAAAmNZ4aAAAE4klEQVRIiZ1We2xTZRT/ne/etivdWtute9CNlS2GDRgqAwETkCibysM4BZUlKARnEAHfglEh0RCMf5gYQggSlFdERKIJEIMRMAMUEe1gwDaRjgJbx7Zu69atu72Pzz/62KtbByf5bm7uOd/5/c7jO98l3IU4jMbsV7IL15akZS3M15vymU6BWw5eP956++hO939bG4LB26P1RaM1XJY7YeUnuVO+NBEzxT6KCpiggOsUBJnc/eHlujf21Xt2jcafMBqjlbmFqz93PrBDT6QfSFsDMQ2cqdAJXD9/rPXpTk1tveDz/5XIZ8KIC63WySemlPwjgnRDaatgogwuKrHoNdLkx06dL65u764eyS9LBPz2uKKNcUEBEAjgFHkLxyAy6DYUjf84kd9EwManbJmLhlPyyOp7IXAApVmWRQCM9wxcbEkrNHBKSkBuiOiIkqbZxxTcM7BZJ6ZEQrlrsQp68z0D39FCraOHGtinTbJ6ZyRrcSTl1ba2uk6o7SnErAAAHp8ngQFcg7c3dOOwt/FAZXP7yWpfV+1Ivoec41m29Eded058Z62z4F1vKOiRwZWHTNaHoxADhHEQ0yCR3L2ptvatjZfrNuRbzROWONPL1z6Y88FLBekrpmckzQyRJrk7JPdAshGxm0yZWwtm7HrcYp8PHq5rbY+/qrz69IKTxU9csghi6pCIBQWdmtyyuKqydIY9dfZHk5xbknWKCYICCBwQZZAogwQF59oCp1f92rSsvqPXEwPONhodP02dV+k0jMnjfGAzbfHUbHD52y7snTzriAHCgCOiCrJS5jozt3SsfdG6vOz1JKhhIFEBRBUQVJCogAQVXBdEs0QNJYduzvb4e+sZANpWNPtAPFAAWJ9bsDk9KclR5jo1193bVQviiK49De5tFqMhbU1O/vpY1TgDuBAZLADAQcQBEDKN3LFvof0gAEFYkJX77DrH/e8NQYzVgtiTtqxnZIL05vW/l1/s9J2XNK3Hp0hNm92X3t9WNG2/TSemEQvPbRI4iIWjjfYAEQcXNBBpyEwmh6eLatjSrLyXhwPt1wi0InP8mrNTS6/NsWaV/tLRdPw5129ldqMxJ99gnJBo/2B5sSBpmTg9xTZztBtSmGApzxhXUZ4xriJVMKwmvSYiTnmGpR/p5akZhumiTRDTOBJdU4O1HFZBtAvEKXw5cHDwsBWPmfSzDrdFVMx6SmXdXOsamTNFBgTFFueAxNWAX+F+4kIMpA+T9+Hyvm9RCSrczy4FOqpGxI1HhQhXujtclwPtruHI9k/twIwRqppDLna05ebBhJfyIPEpocYTrU1nTrc2nfXK0q14sPHJhJ8//Nv9HfvqRt1uj9Rz/W6Av6i/8ikAGYDymfvqptH8uVEkA26/Urezyr+XAQiuqv59aQ/XAkTxPPDIvxUHMY6ffbcP7Wy4tiOq3X/LvfvHloY94R6LuI8OD94v5VxFQOL+5ce8LwCQBABolIKNf3T5Ts6xZZaYBfG+eIw5wL9trN++qubcqwDU/rojXu8Rc5LeWGxLnikwjRGLDAwWHibEODw9Ut2SY54Frmb5IjCoHBmAabGzsKLMnvP8JJOlSCQytspSQ2X7nVPf3Lq2/Vyn78+R0jnRljypIi/ntUczzHPHmuEIqKFgXSBQfbi+4/uva1r2A5Citv8DKD70zHg6DwsAAAAASUVORK5CYII="></img>
  </a>
</p>

## üí° Blueprint

<p align="left">
  <a target="_blank" href="https://ateliware.com/"><img width="200px" alt="Ateliware Logo" title="Ateliware Logo" align="right" src="https://user-images.githubusercontent.com/16140783/223108491-21154956-a674-4138-924a-6ebffd69c463.png"/></a>
</p>

Blueprint is a boilerplate for building APIs using Node.js and Express, written in TypeScript. It is built by Ateliware to provide developers with a fast and efficient starting point for their API development.

## ‚ú® Features

- **Authentication** - Blueprint provides a JWT-based authentication system.
- **Error Handling** - It comes with a centralized error handling fallback middleware, making it easy to handle errors across your entire API.
- **Modular Design** - Blueprint is designed with modularity in mind, allowing you to easily add and remove features as needed.
- **Easy Configuration** - Configuration is made easy with the use of environment variables and a centralized configuration file (see `./src/config/`).
- **Linting** - Blueprint includes ESLint configuration for maintaining code quality and consistency.

More information can be obtained through the [üìö Wiki](https://github.com/ateliware/blueprint-api-express/wiki).

## üöÄ Getting Started

To get started with Blueprint and setup at port 3000, start cloning the repository and install the dependencies:

```sh
git clone https://github.com/ateliware/blueprint-api-express
cd blueprint-api-express
npm install
```

While installing dependencies, you might setup your project settings inside `./src/config/` folder (if needed) and environment variables:

```sh
cp .env.example .env
```

### Running dockerized app

```sh
docker-compose up # start your API and database containers
```

If you rather run blueprint in separate environments:

```sh
docker-compose build # Build before running environment scripts
docker-compose run app-dev # For dev mode
docker-compose run app-test # For test mode
```

### Partially or non-dockerized environment

After setting up your environment configs, you might run:

```sh
docker-compose run -p 5432:5432 db-dev # If you dont have a Postgres DB up already
npm run dev # For dev mode
```

Note that test environment setup is not yet available outside a dockerized app.

## Migrations

### Generate

`npm run typeorm migration:generate -- ./src/migrations/<migration_name>`

### Run

`npm run typeorm migration:run`

### Revert last migration (can be used several times)

`npm run typeorm migration:revert`

### Generating a new migration

1. set synchronize to false and make sure local database is synced with existing migrations in `./src/migrations` folder
2. apply changes to entities
3. run script for generating migration

### Deploying migrations

There are two main options for running migrations, automated and manual. As default, this app is setup to run migrations automatically.

In some cases, a custom script should run just before or just after a migration run in order for the database not to crash (e.g. creating a new column with non-nullable values that needs to be populated), the populating script could be added to the migration file.

The other option for this type of case would be setting migrationsRun to false, SSH into the application's container, and run the scripts and migrations:run command manually, more detailed in the Manual option.

Automated:

1. Generate migration
2. (If needed) Add scripts using queryRunner into migration's up and down methods
3. Deploy application

* As soon as a new deployment takes place, when the application launches, pending migrations run due to migrationsRun being set to true for production in the `./src/config/database.config.ts` file.

Example of migration up/down methods with custom queries for inserting/deleting an admin user:

  Up:

  ```ts
  public async up(queryRunner: QueryRunner): Promise<void> {
    ...
    await queryRunner.query(
      `CREATE TABLE "users" ("id" uuid NOT NULL DEFAULT uuid_generate_v4(), "name" character varying NOT NULL, "email" character varying NOT NULL, "age" integer NOT NULL, "admin" boolean NOT NULL DEFAULT false, "password" character varying NOT NULL, "imageUrl" character varying, "sampleDate" TIMESTAMP DEFAULT '"2023-03-09T19:44:09.752Z"', "sampleStatus" "public"."users_samplestatus_enum" NOT NULL DEFAULT 'FIRSTSTATUS', "sampleBool" boolean NOT NULL DEFAULT false, "accessGroupId" uuid, CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"), CONSTRAINT "PK_a3ffb1c0c8416b9fc6f907b7433" PRIMARY KEY ("id"))`,
    );
    ...
    await queryRunner.manager
      .createQueryBuilder()
      .insert()
      .into(User)
      .values({
        name: 'Admin User',
        email: 'admin@mail.com',
        age: 0,
        admin: true,
        password: await bcrypt.hash('!Password11', BCRYPT_HASH_ROUND),
      })
      .execute();
  }
  ```

  Down:

  ```ts
  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.manager
      .createQueryBuilder()
      .delete()
      .from(User)
      .where({ email: 'admin@mail.com' })
      .execute();
    ...
    await queryRunner.query(`DROP TABLE "users"`);
    ...
  }
  ```

Manual:

0. Set migrationsRun to false for production
1. Generate migration
2. (If needed) Create scripts to run before/after migration
3. Deploy application
4. SSH into application and manually run scripts and migration

Notes:
- The custom scripts added to this file could also just run pure SQL inside queryRunner.query.
- The inserted user's password won't be automatically hashed here due to the @beforeInsert decorator not being called by the migration.
- The scripts added to the migration should be handled with <b>extra care</b>. If you don't feel comfortable or safe using the automated option, you should follow the manual option.



## üå± Seeding

For seeding your database, run `npm run seed`.


* You may additionally setup formatting & linting pre-commit hooks by running `npm run prepare`

## üì≤ Push Notifications

To use the one signal module you need to create an account on the platform or be linked to a corporate account

It is also recommended to update the methods with the project business rule

## Deployments

There are many ways for this application to be deployed. Some guides regarding different cases for deployment are located in the `./deployments` folder.
